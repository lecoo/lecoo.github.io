<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>魔のkyo的工作室</title>
  
  
  <link href="https://kyo86.com/atom.xml" rel="self"/>
  
  <link href="https://kyo86.com/"/>
  <updated>2022-04-25T08:57:16.252Z</updated>
  <id>https://kyo86.com/</id>
  
  <author>
    <name>魔のkyo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx+ngrok共享80端口</title>
    <link href="https://kyo86.com/2022/04/25/nginx-ngrok-share-80/"/>
    <id>https://kyo86.com/2022/04/25/nginx-ngrok-share-80/</id>
    <published>2022-04-25T05:57:00.000Z</published>
    <updated>2022-04-25T08:57:16.252Z</updated>
    
    <content type="html"><![CDATA[<!--toc--><p>上一篇我们讲到 <a href="/2022/04/24/ngrok/">通过ngrok实现内网穿透</a>，在运行服务器时指定了参数 -httpAddr&#x3D;:30080 -httpsAddr&#x3D;:30443</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/ngrokd -domain=ngrok.kyo86.com -tlsKey=./keys/device.key -tlsCrt=./keys/device.crt -httpAddr=:30080 -httpsAddr=:30443</span><br></pre></td></tr></table></figure><p>是为了避免和nginx服务器端口占用冲突，但这会导致我们通过子域名来映射web服务时只能通过30080端口访问，而不是通常的80端口。</p><p>例如我们启动一个hexo博客</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">daimingzhuang@ecs-windows:/mnt/d/Projects/blog$ hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span><br></pre></td></tr></table></figure><p>然后将其使用的4000端口通过hexo子域名映射出去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok.exe -config=&quot;ngrok.cfg&quot; -subdomain=hexo -proto=http 4000</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ngrok                                                                (Ctrl+C to quit)                       Tunnel Status                 online</span><br><span class="line">Version                       1.7/1.7</span><br><span class="line">Forwarding                    http://hexo.ngrok.kyo86.com:30080 -&gt; 127.0.0.1:4000</span><br><span class="line">Web Interface                 127.0.0.1:4040</span><br><span class="line"># Conn                        0</span><br><span class="line">Avg Conn Time                 0.00ms                         </span><br></pre></td></tr></table></figure><p>这时候任何人都可以通过 <code>http://hexo.ngrok.kyo86.com:30080</code> 来访问博客了但这显然不是很令人舒服，我希望能通过 <code>http://hexo.ngrok.kyo86.com</code> 来访问。</p><p>通常80端口会留给nginx使用，在nginx上配置反向代理，根据域名或者根据路径把请求转发到其他端口或者其他内部服务器上。</p><p>下面我们就通过nginx配置将 *.ngrok.kyo86.com 的请求转发到 30080端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><p>新建一个server configuration如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name *.ngrok.kyo86.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1:30080;</span><br><span class="line">                proxy_redirect                    off;</span><br><span class="line">                proxy_set_header Host             $http_host:30080;</span><br><span class="line">                proxy_set_header X-Real-IP        $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">                proxy_read_timeout                120;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server_name来指定域名，特别注意 $http_host:30080 这里一定要指定端口，不然当我们使用 <code>http://hexo.ngrok.kyo86.com</code> 访问时请求确实会被转发到ngrok服务器，但是ngrok会根据 <code>http://hexo.ngrok.kyo86.com</code> 这个地址去寻找tunnel，而被注册的地址是 <code>http://hexo.ngrok.kyo86.com:30080</code> 所以会找不到tunnel，也就无法将请求转发给hexo服务器。</p><p>检测nginx配置文件合法性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx -t</span><br></pre></td></tr></table></figure><p>重启nginx服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>现在就可以通过 <code>http://hexo.ngrok.kyo86.com</code> 来访问hexo博客了，当然仍然可以通过 <code>http://hexo.ngrok.kyo86.com:30080</code> 来访问。</p><p>到现在只剩下一点稍微不爽，就是在运行ngrok客户端时，其中回显</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Forwarding                    http://hexo.ngrok.kyo86.com:30080 -&gt; 127.0.0.1:4000</span><br></pre></td></tr></table></figure><p>仍然带着:30080。</p><p>实际上我们可以把nginx和ngrok绑定在不同IP的80端口上，nginx绑定在公网IP:80，ngrok绑定在localhost:80，这样是没有冲突的。</p><h4><span id="修改nginx配置">修改nginx配置</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/sites-enabled/default</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 172.19.XX.XXX:80;</span><br><span class="line">        server_name *.ngrok.kyo86.com;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass http://127.0.0.1;</span><br><span class="line">                proxy_redirect                    off;</span><br><span class="line">                proxy_set_header Host             $http_host;</span><br><span class="line">                proxy_set_header X-Real-IP        $remote_addr;</span><br><span class="line">                proxy_set_header X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">                proxy_read_timeout                120;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 listen 在端口前面加了IP地址，我在阿里云上，虽然ECS是有公网地址的，但查看ifconfig时没有看到公网地址，我就指定了连接到公网的那块网卡的地址，这时候 $http_host就不要带上:80了，因为这时向ngrok注册tunnel的地址是不带端口的。</p><p>还要注意，<strong>其他的server配置如果是使用80端口，都要改成指定IP地址绑定，不然后面会和ngrok冲突。</strong></p><p>重启nginx服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><h4><span id="运行ngrok服务器">运行ngrok服务器</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/ngrokd -domain=ngrok.kyo86.com -tlsKey=./keys/device.key -tlsCrt=./keys/device.crt -httpAddr=127.0.0.1:80 -httpsAddr=127.0.0.1:443</span><br></pre></td></tr></table></figure><p>这里把端口绑定成了127.0.0.1的80和443。</p><p>启动ngrok客户端，回显变成了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Forwarding                    http://hexo.ngrok.kyo86.com -&gt; 127.0.0.1:4000</span><br></pre></td></tr></table></figure><p>测试访问 <code>http://hexo.ngrok.kyo86.com</code> ，成功，完美。</p><p>如果启动ngrokd时报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic: listen tcp 127.0.0.1:80: bind: address already in use</span><br></pre></td></tr></table></figure><p>去检查nginx配置看是不是所有80端口前都加了IP地址，或者用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep :80</span><br></pre></td></tr></table></figure><p>来查看绑定了80端口的进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!--toc--&gt;

&lt;p&gt;上一篇我们讲到 &lt;a href=&quot;/2022/04/24/ngrok/&quot;&gt;通过ngrok实现内网穿透&lt;/a&gt;，在运行服务器时指定了参数 -httpAddr&amp;#x3D;:30080 -httpsAddr&amp;#x3D;:30443&lt;/p&gt;
&lt;figure </summary>
      
    
    
    
    
    <category term="nginx" scheme="https://kyo86.com/tags/nginx/"/>
    
    <category term="ngrok" scheme="https://kyo86.com/tags/ngrok/"/>
    
  </entry>
  
  <entry>
    <title>通过ngrok实现内网穿透</title>
    <link href="https://kyo86.com/2022/04/24/ngrok/"/>
    <id>https://kyo86.com/2022/04/24/ngrok/</id>
    <published>2022-04-24T08:59:43.000Z</published>
    <updated>2022-04-25T08:46:44.207Z</updated>
    
    <content type="html"><![CDATA[<p>ngrok和ssh-tunnel做的事有点像，ngrok专注于将一个本地服务器暴露到公网。</p><p>它的工作原理是首先有一个<strong>公网的ngrok服务器</strong>，然后在内网需要暴露的机器上通过ngrok客户端建立tunnel来暴露指定端口。</p><p>国内有一些免费的ngrok服务器，也可以自己搭建，这里我自己搭建。</p><h2><span id="搭建ngrok服务器">搭建ngrok服务器</span></h2><p>参考：<a href="https://zhuanlan.zhihu.com/p/149968878">https://zhuanlan.zhihu.com/p/149968878</a></p><h3><span id="下载源码">下载源码</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/inconshreveable/ngrok.git</span><br><span class="line">cd ngrok</span><br></pre></td></tr></table></figure><h3><span id="生成证书">生成证书</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd keys</span><br><span class="line">export NGROK_DOMAIN=&quot;ngrok.kyo86.com&quot;</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br></pre></td></tr></table></figure><h3><span id="替换证书">替换证书</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp rootCA.pem ../assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt ../assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key ../assets/server/tls/snakeoil.key</span><br><span class="line">cd ..</span><br></pre></td></tr></table></figure><h3><span id="编译linux服务端">编译linux服务端</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set GOOS=linux GOARCH=amd64</span><br><span class="line">make release-server</span><br></pre></td></tr></table></figure><h3><span id="编译linux客户端">编译linux客户端</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set GOOS=linux GOARCH=amd64</span><br><span class="line">make release-client</span><br></pre></td></tr></table></figure><p>注意：因为客户端和服务器在编译时都使用了证书，所以他们是一一对应的，就是说ngrok客户端并不是通用的，不能用来连接其他的ngrok服务器。</p><h2><span id="启动服务器端">启动服务器端</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/ngrokd -domain=ngrok.kyo86.com -tlsKey=./keys/device.key -tlsCrt=./keys/device.crt -httpAddr=:30080 -httpsAddr=:30443</span><br></pre></td></tr></table></figure><h3><span id="在客户端建立端口映射">在客户端建立端口映射</span></h3><p>创建配置文件ngrok.cfg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server_addr: &quot;ngrok.kyo86.com:4443&quot;</span><br><span class="line">trust_host_root_certs: false</span><br></pre></td></tr></table></figure><p>暴露服务器有两种方式：</p><p>一是在运行服务器时指定的http和https端口通过子域名的方式来暴露web服务</p><p>二是通过随机端口来暴露指定的tcp端口</p><h4><span id="暴露web服务">暴露WEB服务</span></h4><p>把本地的8080（http）端口映射到通过 <a href="http://jupyter.ngrok.kyo86.com:30080/">http://jupyter.ngrok.kyo86.com:30080</a> 访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok -config=ngrok.cfg -subdomain=jupyter -proto=http 8080</span><br></pre></td></tr></table></figure><p>访问子域名需要指定<strong>泛域名解析</strong>，即 *.ngrok.kyo86.com 的解析。</p><p>如果不指定-proto默认就是http+https</p><h4><span id="暴露tcp端口">暴露TCP端口</span></h4><p>把本地的22（tcp）端口映射到 ngrok.kyo86.com上的一个随机端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./ngrok -config=ngrok.cfg -proto=tcp 22</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;ngrok和ssh-tunnel做的事有点像，ngrok专注于将一个本地服务器暴露到公网。&lt;/p&gt;
&lt;p&gt;它的工作原理是首先有一个&lt;strong&gt;公网的ngrok服务器&lt;/strong&gt;，然后在内网需要暴露的机器上通过ngrok客户端建立tunnel来暴露指定端口。&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="ngrok" scheme="https://kyo86.com/tags/ngrok/"/>
    
    <category term="ssh-tunnel" scheme="https://kyo86.com/tags/ssh-tunnel/"/>
    
  </entry>
  
  <entry>
    <title>WSL备份与还原（安装路径迁移）</title>
    <link href="https://kyo86.com/2022/04/20/wsl-backup-restore/"/>
    <id>https://kyo86.com/2022/04/20/wsl-backup-restore/</id>
    <published>2022-04-20T04:11:13.000Z</published>
    <updated>2022-04-24T08:58:09.288Z</updated>
    
    <content type="html"><![CDATA[<!--toc--><p>通过 wsl export&#x2F;import 命令可以实现WSL的备份与还原，在还原时可以指定安装路径从而实现安装路径迁移。</p><h5><span id="备份">备份</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查看已安装的所有子系统</span><br><span class="line">wsl --list --all</span><br><span class="line"># 查看正在运行的子系统</span><br><span class="line">wsl --list --running</span><br><span class="line"># 若要备份的子系统正在运行，则将其终止</span><br><span class="line">wsl -t Ubuntu-18.04</span><br><span class="line"># 导出子系统到.tar文件 wsl --export &lt;DistributionName&gt; &lt;FileName&gt;</span><br><span class="line">wsl --export Ubuntu-18.04 D:\wsl\backup\ubuntu1804.tar</span><br></pre></td></tr></table></figure><h5><span id="还原">还原</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 注销子系统（视情况，看是否需要）</span><br><span class="line">wsl --unregister Ubuntu-18.04</span><br><span class="line"># 导入子系统 wsl --import &lt;DistributionName&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br><span class="line">wsl --import Ubuntu-18.04 D:\wsl\Ubuntu1804\ D:\wsl\backup\ubuntu1804.tar</span><br></pre></td></tr></table></figure><p>新还原的Ubuntu子系统的默认用户会变成root（无论是在Windows Terminal中打开Ubuntu还是在vscode中通过Remote-WSL启动Ubuntu）<br>可以通过下面的命令</p><h5><span id="修改子系统默认用户">修改子系统默认用户</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 定义函数WSL-SetDefaultUser，接收参数distro和user</span><br><span class="line">Function WSL-SetDefaultUser ($distro, $user) &#123; Get-ItemProperty Registry::HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Lxss\*\ DistributionName | Where-Object -Property DistributionName -eq $distro | Set-ItemProperty -Name DefaultUid -Value ((wsl -d $distro -u $user -e id -u) | Out-String); &#125;;</span><br><span class="line"># 调用函数，WSL-SetDefaultUser &lt;DistroName&gt; &lt;UserName&gt;</span><br><span class="line">WSL-SetDefaultUser Ubuntu-18.04 daimingzhuang</span><br><span class="line"># 取消函数定义</span><br><span class="line">Remove-Item Function:WSL-SetDefaultUser</span><br></pre></td></tr></table></figure><p>参考：</p><p><a href="http://www.xfy-learning.com/2020/05/30/WSL%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/">WSL备份与还原 | 小肥羊吃草不吃肉 (xfy-learning.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;!--toc--&gt;

&lt;p&gt;通过 wsl export&amp;#x2F;import 命令可以实现WSL的备份与还原，在还原时可以指定安装路径从而实现安装路径迁移。&lt;/p&gt;
&lt;h5&gt;&lt;span id=&quot;备份&quot;&gt;备份&lt;/span&gt;&lt;/h5&gt;&lt;figure class=&quot;highligh</summary>
      
    
    
    
    
    <category term="wsl" scheme="https://kyo86.com/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>用WSL安装Ubuntu</title>
    <link href="https://kyo86.com/2022/04/16/wsl-install/"/>
    <id>https://kyo86.com/2022/04/16/wsl-install/</id>
    <published>2022-04-16T10:35:20.000Z</published>
    <updated>2022-04-24T08:58:09.290Z</updated>
    
    <content type="html"><![CDATA[<p>启用“适用于 Linux 的 Windows 子系统”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart</span><br></pre></td></tr></table></figure><p>启用“虚拟机平台”可选组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</span><br></pre></td></tr></table></figure><p>将 WSL 版本设置为 1 或 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --set-default-version 2</span><br></pre></td></tr></table></figure><p>列出已安装的 Linux 发行版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure><p>安装特定的 Linux 发行版</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install -d Ubuntu-18.04</span><br></pre></td></tr></table></figure><p>从官网安装比较慢，也可以下载安装包解压后通过ubuntu1804.exe安装<br><a href="https://pan.baidu.com/s/1Rf9vTiXoUkpWWMQVlICYcw?pwd=7qib">https://pan.baidu.com/s/1Rf9vTiXoUkpWWMQVlICYcw?pwd=7qib</a></p><p>需要注意的是解压路径就是WSL的安装路径，安装好不能移除，否则WSL就损坏了</p><p>BTW：</p><h4><span id="输入wsl-bash找不到路径的问题">输入wsl bash找不到路径的问题</span></h4><p>启用“适用于 Linux 的 Windows 子系统”后找不到，可以先重启再试，和系统版本有关，我遇到过需要重启的系统，也遇到过不需要重启的系统。</p><p>之前可以使用，某种操作后突然不能找不到bash，可能是wsl被损坏，我遇到一次是在ECS上安装Docker Desktop，不能用后将Docker Desktop删除，wsl就损坏了</p><p>解决方案：</p><p>wsl.exe –list –all (列出所有的linux系统)</p><p>wsl.exe –unregister (上面所列出的名字)</p><p>重新安装</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;启用“适用于 Linux 的 Windows 子系统”&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/p</summary>
      
    
    
    
    
    <category term="WSL" scheme="https://kyo86.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>兼容hexo和typora的图片插入方式</title>
    <link href="https://kyo86.com/2022/04/15/hexo-typora-img/"/>
    <id>https://kyo86.com/2022/04/15/hexo-typora-img/</id>
    <published>2022-04-15T09:46:22.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<p>hexo中插入图片通常使用相对网站根的路径，例如将图片放在source&#x2F;images下，那么插入图片的src如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/images/saber.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure><p>而这种方式在typora中编辑时无法正常查看</p><p>其实可以在 md文件头部的配置项中，添加 <code>typora-root-url:</code> 来指定根目录</p><p>hexo source的结构是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">source</span><br><span class="line">├─about</span><br><span class="line">├─images</span><br><span class="line">└─_posts</span><br></pre></td></tr></table></figure><p>我们的博文.md文件在_posts目录下，所以我们可以设置<code>typora-root-url: ../</code>，把根设成source目录</p><p>例如这篇blog的md头部是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 兼容hexo和typora的图片插入方式</span><br><span class="line">date: 2022-04-15 17:46:22</span><br><span class="line">typora-root-url: ../</span><br><span class="line">tags:</span><br><span class="line">- Hexo</span><br></pre></td></tr></table></figure><p>插入下面图片的代码是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;/images/saber.jpg&quot; style=&quot;zoom: 25%;&quot; /&gt;</span><br></pre></td></tr></table></figure><img src="/images/saber.jpg" style="zoom: 25%;"><p>可以在 scaffolds&#x2F;post.md 中加入 <code>typora-root-url: ../</code> 以便执行hexo new命令时自动生成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo中插入图片通常使用相对网站根的路径，例如将图片放在source&amp;#x2F;images下，那么插入图片的src如下&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;</summary>
      
    
    
    
    
    <category term="Hexo" scheme="https://kyo86.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>使用SSH Tunnel+Docker实现类似VPN的功能</title>
    <link href="https://kyo86.com/2022/04/08/ssh-tunnel-docker-vpn/"/>
    <id>https://kyo86.com/2022/04/08/ssh-tunnel-docker-vpn/</id>
    <published>2022-04-07T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.914Z</updated>
    
    <content type="html"><![CDATA[<p>想从家里访问公司局域网内的服务器，最直接的方式就是搭建VPN，我尝试过Ubuntu下使用PPTPD搭建VPN，实际使用下来并不稳定，经常断线，后来有类似需求的时候我都是通过SSH Tunnel完成的。<br>先说一下环境，公司服务器在局域网192.168.1.0&#x2F;24网段，公司网关路由器192.168.1.1上通过端口映射暴露了192.168.1.99的22端口：</p><p>&lt;公司公网IP&gt;:20742  -&gt;192.168.1.99:22</p><p>我要从家里访问公司局域网内的 192.168.1.99:5432 和 192.168.1.166:6379<br>我们可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">autossh -M 0 -CNg -L 5432:192.168.1.99:5432 root@&lt;公司公网IP&gt; -p 20742</span><br><span class="line">autossh -M 0 -CNg -L 6379:192.168.1.166:6379 root@&lt;公司公网IP&gt; -p 20742</span><br></pre></td></tr></table></figure><p>可以先开通本地对跳板机192.168.1.99的密钥登录，然后增加-f参数直接在后台运行，详请搜索SSH密钥登录，使用密码登录时不能加-f</p><p>这样就建立了端口转发</p><p>localhost:5432 -&gt; （公司局域网）192.168.1.99:5432<br>localhost:6379 -&gt; （公司局域网）192.168.1.166:6379</p><p>我有一些程序和脚本里写好了访问的服务器地址就是192.168.1.99 和192.168.1.166，我不想修改成localhost或者127.0.0.1，<br>我们可以通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig enp1s0:0 192.168.1.99 netmask 255.255.255.255 up</span><br><span class="line">ifconfig enp1s0:1 192.168.1.166 netmask 255.255.255.255 up</span><br></pre></td></tr></table></figure><p>创建虚拟网卡并把IP设置为192.168.1.99和192.168.1.166，这样这两个IP都指向了本地。<br>至此需求就解决了。</p><p>但是更进一步，如果我想访问的两个服务器上的相同端口，例如 192.168.1.99:6379 和 192.168.1.166:6379 怎么办呢？<br>我想到了做两个容器分别去建立SSH Tunnel，并把两个容器的IP设置分别设置为 192.168.1.99和192.168.1.166<br>首先我们创建一个docker network在 192.168.1.0&#x2F;24网段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create --gateway=192.168.1.1 --subnet=192.168.1.0/24 company</span><br></pre></td></tr></table></figure><p>创建一个ubuntu容器加入company网络并指定IP地址为192.168.1.99，同时暴露6379端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit --name proxy99 -h proxy99 --net company --ip 192.168.1.99 --expose 6379 daimingzhuang/ubuntu:18.04 bash</span><br></pre></td></tr></table></figure><p>连上去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it proxy99 bash</span><br></pre></td></tr></table></figure><p>和前面一样建立SSH Tunnel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autossh -M 0 -CNg -L 6379:192.168.1.99:6379 root@&lt;公司公网IP&gt; -p 20742</span><br></pre></td></tr></table></figure><p>在宿主机上通过redis-cli连接192.168.1.99:6379</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.1.99</span><br></pre></td></tr></table></figure><p>成功<br>192.168.1.166:6379 也同样操作<br>总结起来就是用docker创建跳板机容器，用ssh tunnel做端口映射。 </p><p>我做了一个docker镜像(daimingzhuang&#x2F;ssh_proxy)来方便进行上面的操作<br>Dockerfile</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:18.04</span><br><span class="line">MAINTAINER DaiMingzhuang &quot;kyo86.dai@gmail.com&quot;</span><br><span class="line">ENV REFRESHED_AT=2022-04-07</span><br><span class="line">RUN echo deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse&gt;&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse&gt;&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse&gt;&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse&gt;&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse&gt;&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse&gt;&gt;/etc/apt/sources.list\</span><br><span class="line">    &amp;&amp; echo deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse&gt;&gt;/etc/apt/sources.list</span><br><span class="line">RUN apt update -yqq \</span><br><span class="line">    &amp;&amp; apt install -y vim-tiny autossh expect \</span><br><span class="line">    &amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; ln -s /usr/bin/vim.tiny /usr/bin/vim</span><br><span class="line"></span><br><span class="line">EXPOSE 22 80 8080 1433 3306 6379 9092 5432 27017</span><br><span class="line"></span><br><span class="line">ADD setup.sh /root/setup.sh</span><br><span class="line">WORKDIR &quot;/root/&quot;</span><br><span class="line">CMD [&quot;bash&quot;]</span><br></pre></td></tr></table></figure><p>&#x2F;root&#x2F;setup.sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">user=&#x27;root&#x27;</span><br><span class="line">passwd=&#x27;跳板机密码&#x27;</span><br><span class="line">LAN_IP=&#x27;跳板机局域网IP&#x27;</span><br><span class="line">WAN_IP=&#x27;网关的公网IP&#x27;</span><br><span class="line">WAN_PORT=跳板机通过端口映射暴露在公网的SSH端口</span><br><span class="line">ports=(22 80 8080 1433 3306 6379 9092 5432 27017)</span><br><span class="line"></span><br><span class="line">for((i=0;i&lt;$&#123;#ports[@]&#125;;i++)); do</span><br><span class="line"></span><br><span class="line">/usr/bin/expect &lt;&lt;-EOF</span><br><span class="line">set time 10</span><br><span class="line">spawn autossh -M 0 -CNg -L $&#123;ports[$i]&#125;:$LAN_IP:$&#123;ports[$i]&#125; $user@$WAN_IP -p $WAN_PORT</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*(yes/no)?&quot; &#123; send &quot;yes\n&quot;; exp_continue &#125;</span><br><span class="line">&quot;*password:&quot; &#123; send &quot;$passwd\n&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;想从家里访问公司局域网内的服务器，最直接的方式就是搭建VPN，我尝试过Ubuntu下使用PPTPD搭建VPN，实际使用下来并不稳定，经常断线，后来有类似需求的时候我都是通过SSH Tunnel完成的。&lt;br&gt;先说一下环境，公司服务器在局域网192.168.1.0&amp;#x2F;</summary>
      
    
    
    
    
    <category term="ssh-tunnel" scheme="https://kyo86.com/tags/ssh-tunnel/"/>
    
    <category term="docker" scheme="https://kyo86.com/tags/docker/"/>
    
    <category term="vpn" scheme="https://kyo86.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>使用binlog2sql还原数据到任意时间点</title>
    <link href="https://kyo86.com/2022/04/07/binlog2sql/"/>
    <id>https://kyo86.com/2022/04/07/binlog2sql/</id>
    <published>2022-04-06T16:00:00.000Z</published>
    <updated>2022-04-19T13:57:49.827Z</updated>
    
    <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C">准备工作</a><ul><li><a href="#%E5%88%9B%E5%BB%BAbinlog2sql%E8%B4%A6%E5%8F%B7">创建binlog2sql账号</a></li><li><a href="#%E6%8E%88%E6%9D%83">授权</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE">服务器配置</a></li><li><a href="#%E4%B8%8B%E8%BD%BDbinlog2sql">下载binlog2sql</a></li><li><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">安装依赖</a></li><li><a href="#%E5%88%9B%E5%BB%BAbinlog2sql%E5%88%AB%E5%90%8D">创建binlog2sql别名</a></li></ul></li><li><a href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E4%B8%80%E4%B8%AAbinlog%E6%96%87%E4%BB%B6%E8%AE%B0%E5%BD%95%E7%9A%84position%E7%9A%84%E8%8C%83%E5%9B%B4">如何查看一个binlog文件记录的position的范围？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E7%95%99%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD">如何保留一个数据库的全量备份？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E8%BF%98%E5%8E%9F%E4%B8%80%E4%B8%AA%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD">如何还原一个全量备份？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E7%94%A8binlog%E8%BF%98%E5%8E%9F%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD">如何用binlog还原增量备份？</a></li><li><a href="#%E5%A6%82%E4%BD%95%E5%9C%A8%E6%B2%A1%E6%9C%89%E5%85%A8%E9%87%8F%E5%A4%87%E4%BB%BD%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%B0%86%E6%95%B0%E6%8D%AE%E5%BA%93%E9%80%80%E5%9B%9E%E5%88%B0%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E7%82%B9">如何在没有全量备份的情况下将数据库退回到指定时间点？</a></li></ul><!-- tocstop --><h2><span id="准备工作">准备工作</span></h2><h3><span id="创建binlog2sql账号">创建binlog2sql账号</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> binlog2sql@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;binlog2sql&#x27;</span>;</span><br></pre></td></tr></table></figure><h3><span id="授权">授权</span></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, REPLICATION SLAVE, REPLICATION CLIENT <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> binlog2sql@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;binlog2sql&#x27;</span>;</span><br><span class="line">FLUSH privileges;</span><br></pre></td></tr></table></figure><h3><span id="服务器配置">服务器配置</span></h3><p>默认配置文件路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/mysql/mysql.conf.d/mysqld.cnf</span><br></pre></td></tr></table></figure><p>查找server-id，附近的选项按如下设置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server_id = 1</span><br><span class="line">log_bin = /var/log/mysql/mysql-bin.log # 开启binlog，设置路径</span><br><span class="line">max_binlog_size = 1G # 设置单个binlog大小上限</span><br><span class="line">binlog_format = row # 设置binlog模式，binlog2sql要求必须是row模式</span><br><span class="line">binlog_row_image = full # 默认的，可以不设</span><br></pre></td></tr></table></figure><p>重启mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart</span><br></pre></td></tr></table></figure><h3><span id="下载binlog2sql">下载binlog2sql</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/danfengcao/binlog2sql.git /opt/binlog2sql</span><br></pre></td></tr></table></figure><h3><span id="安装依赖">安装依赖</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r /opt/binlog2sql/requirements.txt</span><br></pre></td></tr></table></figure><h3><span id="创建binlog2sql别名">创建binlog2sql别名</span></h3><p>为了方便使用binlog2sql.py脚本，可以把别名设置写在~&#x2F;.bash_aliases文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alias binlog2sql=&#x27;python /opt/binlog2sql/binlog2sql/binlog2sql.py -h 127.0.0.1 -u binlog2sql -p binlog2sql&#x27;</span><br></pre></td></tr></table></figure><h2><span id="如何查看一个binlog文件记录的position的范围">如何查看一个binlog文件记录的position的范围？</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog -v mysql-bin.000010|tail -n 100|less</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line"># at 4356297</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356362 CRC32 0xeb816e97      Anonymous_GTID  last_committed=5723     sequence_number=5</span><br><span class="line">724    rbr_only=yes</span><br><span class="line">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 4356362</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356439 CRC32 0x91cd3acc      Query   thread_id=45    exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1648879939/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 4356439</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356548 CRC32 0x6635890f      Table_map: `gogoal_v2`.`rpt_target_price_adjust` mapped t</span><br><span class="line">o number 226</span><br><span class="line"># at 4356548</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356766 CRC32 0xa3f8f451      Write_rows: table id 226 flags: STMT_END_F</span><br><span class="line"></span><br><span class="line">BINLOG &#x27;</span><br><span class="line">Q+lHYhMBAAAAbQAAAMR5QgAAAOIAAAAAAAEACWdvZ29hbF92MgAXcnB0X3RhcmdldF9wcmljZV9h</span><br><span class="line">ZGp1c3QAFAMDDw8PAwMPDwoKBQUFAxISCBISETwAlgDCAZYAWAIICAgAAAAA/v8PD4k1Zg==</span><br><span class="line">Q+lHYh4BAAAA2gAAAJ56QgAAAOIAAAAAAAEAAgAU////AAD8HekUABzdFQAGMDAwMDAyB+S4h+en</span><br><span class="line">kUE3AOS4h+enkUHvvJrliKnmtqbnjofljovlipvph4rmlL7vvIzmlrDkuJrliqHlhZHnjrDlop7p</span><br><span class="line">lb8WAAAAPQAAAAzlub/lj5Hor4HliLgXAOmDremVhyzkuZDliqDmoIss6YKi6I6YgcwPS8wPKVyP</span><br><span class="line">wvVoPEAzMzMzM3M5QGZmZmZmJjNAAgAAAJmshMqAmayEyoBC83pdAQAAAFH0+KM=</span><br><span class="line">&#x27;/*!*/;</span><br><span class="line">### INSERT INTO `gogoal_v2`.`rpt_target_price_adjust`</span><br><span class="line">### SET</span><br><span class="line">###   @1=1370397</span><br><span class="line">###   @2=1432860</span><br><span class="line">###   @3=&#x27;000002&#x27;</span><br><span class="line">###   @4=&#x27;万科A&#x27;</span><br><span class="line">###   @5=&#x27;万科A：利润率压力释放，新业务兑现增长&#x27;</span><br><span class="line">###   @6=22</span><br><span class="line">###   @7=61</span><br><span class="line">###   @8=&#x27;广发证券&#x27;</span><br><span class="line">###   @9=&#x27;郭镇,乐加栋,邢莘&#x27;</span><br><span class="line">###   @10=&#x27;2022:04:01&#x27;</span><br><span class="line">###   @11=&#x27;2022:02:11&#x27;</span><br><span class="line">###   @12=28.410000000000000142</span><br><span class="line">###   @13=25.449999999999999289</span><br><span class="line">###   @14=19.149999999999998579</span><br><span class="line">###   @15=2</span><br><span class="line">###   @16=&#x27;2022-04-02 12:42:00&#x27;</span><br><span class="line">###   @17=&#x27;2022-04-02 12:42:00&#x27;</span><br><span class="line">###   @18=5863306050</span><br><span class="line">###   @19=NULL</span><br><span class="line">###   @20=NULL</span><br><span class="line"># at 4356766</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356797 CRC32 0x5d69576f      Xid = 715129</span><br><span class="line">COMMIT/*!*/;</span><br><span class="line"># at 4356797</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356862 CRC32 0x941d7ebe      Anonymous_GTID  last_committed=5724     sequence_number=5725    rbr_only=yes</span><br><span class="line">/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;/*!*/;</span><br><span class="line"># at 4356862</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4356939 CRC32 0x25f3bc96      Query   thread_id=45    exec_time=0     error_code=0</span><br><span class="line">SET TIMESTAMP=1648879939/*!*/;</span><br><span class="line">BEGIN</span><br><span class="line">/*!*/;</span><br><span class="line"># at 4356939</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4357048 CRC32 0x94e54d42      Table_map: `gogoal_v2`.`rpt_target_price_adjust` mapped to number 226</span><br><span class="line"># at 4357048</span><br><span class="line">#220402 14:12:19 server id 1  end_log_pos 4357304 CRC32 0x6be0ae0b      Write_rows: table id 226 flags: STMT_END_F</span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>其中的 #at 后面的数字就是position，文件首个和最后一个position就是这个binlog记录的position的范围。</p><p>另外，举例来说，如果我们要解析出的insert语句，需要从4356362解析到4356766，从BEGIN上面的position到COMMIT上面的position，至于update或delete应该是类似的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog2sql -d gogoal_v2 --start-file=mysql-bin.000010 --start-position=4356362 --stop-position=4356766</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `gogoal_v2`.`rpt_target_price_adjust`(`id`, `report_id`, `stock_code`, `stock_name`, `title`, `report_type`, `organ_id`, `organ_name`, `author`, `current_create_date`, `previous_create_date`, `current_target_price`, `previous_target_price`, `current_price`, `price_adjust_mark`, `entrytime`, `updatetime`, `tmstamp`, `UTSUPTIME`, `UTSFIRSTTIME`) VALUES (1370397, 1432860, &#x27;000002&#x27;, &#x27;万科A&#x27;, &#x27;万科A：利润率压力释放，新业务兑现增长&#x27;, 22, 61, &#x27;广发证券&#x27;, &#x27;郭镇,乐加栋,邢莘&#x27;, &#x27;2022-04-01&#x27;, &#x27;2022-02-11&#x27;, 28.41, 25.45, 19.15, 2, &#x27;2022-04-02 12:42:00&#x27;, &#x27;2022-04-02 12:42:00&#x27;, 5863306050, NULL, NULL); #start 4356439 end 4356766 time 2022-04-02 14:12:19</span><br></pre></td></tr></table></figure><h2><span id="如何保留一个数据库的全量备份">如何保留一个数据库的全量备份？</span></h2><p>有两种形式，一种是通过mysqldump把数据库导出成sql，正常应该通过这种形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --master-data=2 gogoal_v2&gt; /data/dbbackup/20220406/gogoal_v2.sql</span><br></pre></td></tr></table></figure><p>这里的–master-data&#x3D;2选项会在生成的sql中生成被注释掉的 CHANGE MASTER 命令，里面有binlog文件编号和位置编号</p><p>另一种是直接备份数据库目录，我们的mysql中只有一个数据库gogoal_v2，所以备份目录是最方便的。<br>那么我们就要手动确定备份下来截止的binlog编号和位置编号，为了防止一边备份数据库一边在变，我们需要先停止数据库，而恰好我们操作的这个数据库又不是生产环境使用的，可以随时停止</p><p>首先停止数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><p>查看&#x2F;data&#x2F;mysql-binlog下最新的binlog文件和最新的position并记录下来，可以写在后面的备份目录下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql-bin.000012 5055197</span><br></pre></td></tr></table></figure><p>备份&#x2F;var&#x2F;lib&#x2F;mysql下的全部文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -rp /var/lib/mysql /data/dbbackup/20220406/</span><br></pre></td></tr></table></figure><p>最后在恢复启动数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql start</span><br></pre></td></tr></table></figure><h2><span id="如何还原一个全量备份">如何还原一个全量备份？</span></h2><p>我们将备份还原到一个新的mysql容器中</p><p>首先创建一个mysql容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -Pdit daimingzhuang/mysql</span><br></pre></td></tr></table></figure><p>daimingzhuang&#x2F;mysql和官方mysql容器的区别是按原mysql的配置做了字符编码、大小写相关的设置，允许root远程访问，设置了默认密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lower_case_table_names=1</span><br><span class="line">character_set_server=utf8mb4</span><br><span class="line">collation-server=utf8mb4_unicode_ci</span><br><span class="line">init_connect=&#x27;SET NAMES utf8mb4&#x27;</span><br><span class="line">skip-character-set-client-handshake=true</span><br></pre></td></tr></table></figure><p>实际使用的命令还包含了资源使用限制</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql -Pdit \</span><br><span class="line">--cpuset-cpus=&quot;1,3&quot; \</span><br><span class="line">--memory=4G \</span><br><span class="line">--device-read-bps /dev/sdd:80mb \</span><br><span class="line">--device-write-bps /dev/sdd:50mb \</span><br><span class="line">--device-read-bps /dev/sdb:80mb \</span><br><span class="line">--device-write-bps /dev/sdb:50mb \</span><br><span class="line">daimingzhuang/mysql</span><br></pre></td></tr></table></figure><p>然后连到容器停止mysql服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bash</span><br><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><p>把备份文件复制到容器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /data/dbbackup/20220406/mysql mysql:/var/lib/mysql</span><br></pre></td></tr></table></figure><p>还需要复制debian.cnf解决服务控制权限问题（里面有debian-sys-maint用户的密码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /etc/mysql/debian.cnf 容器名:/etc/mysql/debian.cnf</span><br></pre></td></tr></table></figure><p>再到容器中修改目录权限并启动mysql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R mysql:mysql /var/lib/mysql</span><br><span class="line">service mysql start </span><br></pre></td></tr></table></figure><h2><span id="如何用binlog还原增量备份">如何用binlog还原增量备份？</span></h2><p>下面将在前面已经还原了全量备份的基础上，继续利用binlog还原到指定时间点<br>我们先看一下当前binlog文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /var/log/mysql</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">total 1221304</span><br><span class="line">drwx------ 2 mysql mysql      1024 Apr  7 06:25 ./</span><br><span class="line">drwxr-xr-x 8 root  root       1024 Apr  6 20:14 ../</span><br><span class="line">-rw-r----- 1 mysql mysql 164683302 Mar 26 06:25 mysql-bin.000001</span><br><span class="line">-rw-r----- 1 mysql mysql   1146243 Mar 27 06:25 mysql-bin.000002</span><br><span class="line">-rw-r----- 1 mysql mysql   5487816 Mar 28 06:25 mysql-bin.000003</span><br><span class="line">-rw-r----- 1 mysql mysql 176003823 Mar 29 06:25 mysql-bin.000004</span><br><span class="line">-rw-r----- 1 mysql mysql 180791383 Mar 30 06:25 mysql-bin.000005</span><br><span class="line">-rw-r----- 1 mysql mysql 189424937 Mar 31 06:25 mysql-bin.000006</span><br><span class="line">-rw-r----- 1 mysql mysql 177521662 Apr  1 06:25 mysql-bin.000007</span><br><span class="line">-rw-r----- 1 mysql mysql   1704056 Apr  1 10:43 mysql-bin.000008</span><br><span class="line">-rw-r----- 1 mysql mysql 172659973 Apr  2 06:25 mysql-bin.000009</span><br><span class="line">-rw-r----- 1 mysql mysql   4357335 Apr  2 18:28 mysql-bin.000010</span><br><span class="line">-rw-r----- 1 mysql mysql   1212646 Apr  2 22:33 mysql-bin.000011</span><br><span class="line">-rw-r----- 1 mysql mysql   5055220 Apr  6 17:01 mysql-bin.000012</span><br><span class="line">-rw-r----- 1 mysql mysql 166213563 Apr  7 06:25 mysql-bin.000013</span><br><span class="line">-rw-r----- 1 mysql mysql   4326594 Apr  7 14:12 mysql-bin.000014</span><br><span class="line">-rw-r----- 1 mysql mysql       504 Apr  7 06:25 mysql-bin.index</span><br></pre></td></tr></table></figure><p>我们可以估计需要还原到的数据点在哪个binlog文件中，比如我想还原到20220407 0点，那就应该在这里 Apr 7 06:25 mysql-bin.000013 ，事实上我们把000014或更多的binlog包含进来不要紧，只是浪费了执行命令的过滤时间</p><p>在原mysql上从binlog解析出全量备份后的增量sql</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog2sql -d gogoal_v2 --start-file=mysql-bin.000013 --stop-file=mysql-bin.000014 --stop-datetime=&#x27;2022-04-07 00:00:00&#x27; &gt; inc_20220407000000.sql</span><br></pre></td></tr></table></figure><p>–start-file和–start-position根据全量备份时记录的位置设置，我们全量备份时候记录的是mysql-bin.000012 5055197 ，而事实上因为我们在做全量备份的时候停止了mysql服务，重启后会写入新的binlog，所以我们可以从mysql-bin.000013开始还原，–stop-datetime 指定了还原到的时间点</p><p>把增量sql复制到容器内</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp ./inc_20220407000000.sql mysql:/root/</span><br></pre></td></tr></table></figure><p>在容器内执行还原</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mysql bash</span><br><span class="line">mysql gogoal_v2 &lt; /root/inc_20220407000000.sql </span><br></pre></td></tr></table></figure><h2><span id="如何在没有全量备份的情况下将数据库退回到指定时间点">如何在没有全量备份的情况下将数据库退回到指定时间点？</span></h2><p>当前时间 2022-04-12 13:38:00</p><p>假设我们想退回到 2022-04-11 15:00:00</p><p>在有全量备份的情况下我们可以通过上面的方法先还原全量备份再叠加通过binlog导出的增量sql来还原，但在没有全量备份或者全量备份比较久远的情况下，我们也可以通过binlog2sql导出基于当前数据的回退sql来还原。</p><p>首先停止数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql stop</span><br></pre></td></tr></table></figure><p>还是先看一下当前binlog文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ll /var/log/mysql</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">total 1732017</span><br><span class="line">drwx------ 2 mysql mysql      1024 Apr 12 13:39 ./</span><br><span class="line">drwxr-xr-x 8 root  root       1024 Apr  6 20:14 ../</span><br><span class="line">-rw-r----- 1 mysql mysql 164683302 Mar 26 06:25 mysql-bin.000001</span><br><span class="line">-rw-r----- 1 mysql mysql   1146243 Mar 27 06:25 mysql-bin.000002</span><br><span class="line">-rw-r----- 1 mysql mysql   5487816 Mar 28 06:25 mysql-bin.000003</span><br><span class="line">-rw-r----- 1 mysql mysql 176003823 Mar 29 06:25 mysql-bin.000004</span><br><span class="line">-rw-r----- 1 mysql mysql 180791383 Mar 30 06:25 mysql-bin.000005</span><br><span class="line">-rw-r----- 1 mysql mysql 189424937 Mar 31 06:25 mysql-bin.000006</span><br><span class="line">-rw-r----- 1 mysql mysql 177521662 Apr  1 06:25 mysql-bin.000007</span><br><span class="line">-rw-r----- 1 mysql mysql   1704056 Apr  1 10:43 mysql-bin.000008</span><br><span class="line">-rw-r----- 1 mysql mysql 172659973 Apr  2 06:25 mysql-bin.000009</span><br><span class="line">-rw-r----- 1 mysql mysql   4357335 Apr  2 18:28 mysql-bin.000010</span><br><span class="line">-rw-r----- 1 mysql mysql   1212646 Apr  2 22:33 mysql-bin.000011</span><br><span class="line">-rw-r----- 1 mysql mysql   5055220 Apr  6 17:01 mysql-bin.000012</span><br><span class="line">-rw-r----- 1 mysql mysql 166213563 Apr  7 06:25 mysql-bin.000013</span><br><span class="line">-rw-r----- 1 mysql mysql 173374732 Apr  8 06:25 mysql-bin.000014</span><br><span class="line">-rw-r----- 1 mysql mysql 171723561 Apr  9 06:25 mysql-bin.000015</span><br><span class="line">-rw-r----- 1 mysql mysql    471311 Apr 10 06:25 mysql-bin.000016</span><br><span class="line">-rw-r----- 1 mysql mysql   3800429 Apr 11 06:25 mysql-bin.000017</span><br><span class="line">-rw-r----- 1 mysql mysql 176073129 Apr 12 06:25 mysql-bin.000018</span><br><span class="line">-rw-r----- 1 mysql mysql   1845781 Apr 12 12:41 mysql-bin.000019</span><br><span class="line">-rw-r----- 1 mysql mysql       684 Apr 12 06:25 mysql-bin.index</span><br></pre></td></tr></table></figure><p>我们可以估计需要还原到的时间点 2022-04-11 15:00:00 应该在 mysql-bin.000018 中，那么回退需要用到的binlog就是从000018到000019，导出回退sql的命令如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binlog2sql --flashback -d gogoal_v2 --start-file=mysql-bin.000018 --stop-file=mysql-bin.000019 --start-date=&quot;2022-04-11 15:00:00&quot; &gt; flashback.sql</span><br></pre></td></tr></table></figure><p>和之前命令的区别就是–flashback选项，表示导出符合指定条件内的回退sql语句。</p><p>之后创建一个新的mysql容器，把当前数据的&#x2F;var&#x2F;lib&#x2F;mysql复制到容器中，修正权限。不要忘了重新启动前面停止的mysql服务。再把flashback.sql导入到容器数据库中即可实现回退。具体语句参照前面已经讲过的内容。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- toc --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C&quot;&gt;准备工作&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%9B%E5%BB%BAbinlog2sql%E8%B4%A6%E5%8</summary>
      
    
    
    
    
    <category term="mysql" scheme="https://kyo86.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>docker常用命令</title>
    <link href="https://kyo86.com/2022/03/28/docker/"/>
    <id>https://kyo86.com/2022/03/28/docker/</id>
    <published>2022-03-27T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="启动一个容器">启动一个容器</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -h 容器主机名 --name 容器名 -Pdit 镜像名</span><br></pre></td></tr></table></figure><h4><span id="启动一个新的bash进行管理">启动一个新的bash进行管理</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 容器名 bash</span><br></pre></td></tr></table></figure><h4><span id="其他常用命令">其他常用命令</span></h4><table><thead><tr><th></th><th>镜像</th><th>容器</th></tr></thead><tbody><tr><td>创建</td><td>build -t&#x2F;commit</td><td>create&#x2F;run</td></tr><tr><td>删除</td><td>rmi</td><td>rm</td></tr><tr><td>重命名</td><td>tag+rmi</td><td>rename</td></tr><tr><td>查看列表</td><td>images</td><td>ps&#x2F;ps -a&#x2F;ps -l -q</td></tr><tr><td>运行状态</td><td>stats</td><td>top</td></tr><tr><td>查看日志</td><td>history</td><td>logs</td></tr><tr><td>登录</td><td>login</td><td></td></tr><tr><td>拉取</td><td>pull</td><td></td></tr><tr><td>推送</td><td>push</td><td></td></tr><tr><td>查找</td><td>search</td><td></td></tr><tr><td>查看容器信息</td><td></td><td>inspect</td></tr><tr><td>发信号</td><td></td><td>kill</td></tr><tr><td>附到主进程</td><td></td><td>attach</td></tr><tr><td>执行新进程</td><td></td><td>exec</td></tr></tbody></table><h4><span id="docker-run-常用参数">docker run 常用参数</span></h4><p>-d   # 后台运行<br>-it   # 打开STDIN，支持终端登录<br>–name &lt;容器名&gt;<br>-h &lt;主机名&gt;<br>-P   # 随机映射所有配置在EXPOSE中的端口<br>-p [&lt;宿主端口&gt;:]&lt;容器端口&gt; # 指定映射一个端口，不指定宿主端口时表示随机<br>–expose &lt;容器端口&gt;  # 指定暴露一个容器端口，但不映射到宿主机<br>-v &lt;宿主路径&gt;:&lt;容器路径&gt;[:ro|:rw] # 卷映射，容器路径不存在时自动创建，ro表示只读，默认是rw表示读写<br>–volumes-from &lt;容器名&gt; # 指定容器里的所有卷都将加入到新创建的容器里<br>–network &lt;网络名&gt; # 默认bridge，同一个非默认网络下的容器可以使用主机名相互访问，特别的，如果设置为host，表示和宿主机共用网络，这时容器内绑定的端口都将直接绑定到宿主机而不需要通过-p建立映射<br>–link &lt;容器名&gt;:&lt;主机名&gt;  # 在新创建的容器里可以通过主机名访问另一个运行中的容器<br>–add-host &lt;主机名&gt;:<ip> # 指定主机名解析添加到&#x2F;etc&#x2F;hosts文件<br>–env &lt;环境变量名&gt;&#x3D;&lt;环境变量值&gt;  # 设置环境变量，-e 选项可以重复多次<br>–env-file &lt;环境变量文件&gt;  # 指定环境变量文件，换行符分割<br>–user &lt;用户名&gt;<br>–workdir &lt;工作目录&gt;<br>–mac-address&#x3D;”xx:xx:xx:xx:xx:xx”   # 指定MAC地址<br>–ip&#x3D;”x.x.x.x”  # 指定IP地址</ip></p><h5><span id="关于资源限制的参数">关于资源限制的参数：</span></h5><p>–cpuset-cpus&#x3D;”1,3” # 限制在核1、3上运行<br>–memory&#x3D;1G # 限制内存最大使用1G<br>–device-read-bps &#x2F;dev&#x2F;sdd:40mb # 限制读取sdd的速度最大40mb<br>–device-write-bps &#x2F;dev&#x2F;sdd:30mb # 限制写入sdd的速度最大30mb<br>（机械硬盘读写速度是60-80MB，固态硬盘读写速度是130~300MB，都是写慢读快）</p><h4><span id="docker-network-常用参数">docker network 常用参数</span></h4><p>  create [–gateway&#x3D;192.168.1.1] [–subnet&#x3D;192.168.1.0&#x2F;24] &lt;网络名&gt;   # 创建一个新的网络<br>  connect &lt;网络名&gt; &lt;容器名&gt;  # 向一个网络中添加一个容器<br>  disconnect &lt;网络名&gt; &lt;容器名&gt;  # 从一个网络中移除一个容器<br>  inspect &lt;网络名&gt;   # 查看指定网络详细信息<br>  ls              # 查看网络列表<br>  rm &lt;网络名&gt;  # 删除指定网络<br>  prune      # 删除所有未使用的网络</p><h4><span id="docker-inspect-常用参数">docker inspect 常用参数</span></h4><p>–format format的用法比较复杂，用几个逐级深入的例子演示，事实上我通常把docker_ip, docker_volume设成Linux别名方便使用</p><p>docker_id 查看容器的Id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;.Id&#125;&#125;&#x27; 容器名</span><br></pre></td></tr></table></figure><p>docker_ip 查看容器在所有网络中分配的所有的ip</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;println .IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 容器名</span><br></pre></td></tr></table></figure><p>docker_volume 查看容器的卷</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;range .Mounts&#125;&#125;&#123;&#123;.Source&#125;&#125;:&#123;&#123;.Destination&#125;&#125;&#123;&#123;println&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 容器名</span><br></pre></td></tr></table></figure><p>docker_port 查看容器所有的端口映射情况，用docker inspect实现 docker port命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect --format=&#x27;&#123;&#123;range $p, $conf := .NetworkSettings.Ports&#125;&#125;&#123;&#123;range $conf&#125;&#125;&#123;&#123;$p&#125;&#125; -&gt; &#123;&#123;.HostIp&#125;&#125;:&#123;&#123;.HostPort&#125;&#125;&#123;&#123;println&#125;&#125;&#123;&#123;end&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; 容器名</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;启动一个容器&quot;&gt;启动一个容器&lt;/span&gt;&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;b</summary>
      
    
    
    
    
    <category term="docker" scheme="https://kyo86.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>在Shell脚本中输入密码</title>
    <link href="https://kyo86.com/2022/02/21/password-in-sh/"/>
    <id>https://kyo86.com/2022/02/21/password-in-sh/</id>
    <published>2022-02-20T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.914Z</updated>
    
    <content type="html"><![CDATA[<p>在Shell脚本中输入密码的几种情况</p><h4><span id="如果是要使用sudo">如果是要使用sudo</span></h4><p>首先在Shell脚本中使用sudo不是一个好主意。</p><p>可以考虑的替代方案有，</p><ol><li>在脚本中去掉sudo，而要求在运行脚本时使用sudo。</li><li>如果是任务计划，考虑配置在root用户下。</li></ol><p>在确定要在Shell中sudo的情况下可以使用如下方式 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;密码&#x27; | sudo -S 命令 </span><br></pre></td></tr></table></figure><h4><span id="如果是通过sshx2fautossh建立远程连接或建立tunnel">如果是通过ssh&#x2F;autossh建立远程连接或建立tunnel</span></h4><p>考虑用SSH密钥登录来避免使用密码</p><p>例如我们要从 hostA 通过ssh密钥登录 hostB</p><p>我们现在 hostA 上生成密钥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>会询问将密钥放在何处，默认即可。然后是输入密码，留空(否则你登录不仅需要私钥还要输入密码)。</p><p>完成后在~&#x2F;.ssh目录下会生成两个文件id_rsa和id_rsa.pub，一个私钥一个公钥。</p><p>把公钥追加到 hostB 某个用户的 ~&#x2F;.ssh&#x2F;authorized_keys 就代表 hostB 的这个用户允许持有相应私钥登录</p><p>ssh-copy-id命令可以帮我们完成追加公钥的操作</p><p>命令格式：ssh-copy-id [-p SSH端口默认22] [user@]hostname</p><p>在 hostA 上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id root@hostB</span><br></pre></td></tr></table></figure><p>按提示输出密码即可</p><p>还需要确保 hostB 的sshd服务配置允许使用公钥授权</p><p>配置文件路径 &#x2F;etc&#x2F;ssh&#x2F;sshd_config</p><p>确认</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PubkeyAuthentication yes</span><br></pre></td></tr></table></figure><p>如果修改过配置需要重启sshd服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure><p>在hostA上现在可以验证登录hostB不再需要输入密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@hostB</span><br></pre></td></tr></table></figure><h4><span id="其他情况或其他程序需要输入密码">其他情况或其他程序需要输入密码</span></h4><p>可以用expect工具，事实上这种方法也可以应对上面的几种情况</p><p>使用autossh+expect建立ssh tunnel的用法举例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">passwd=&#x27;123456&#x27;</span><br><span class="line"></span><br><span class="line">/usr/bin/expect &lt;&lt;-EOF</span><br><span class="line"></span><br><span class="line">set time 10</span><br><span class="line">spawn autossh -M 0 -CNg -L 1433:192.168.1.140:1433 root@$WAN_IP -p $WAN_PORT</span><br><span class="line">expect &#123;</span><br><span class="line">&quot;*yes/no&quot; &#123; send &quot;yes\n&quot;; exp_continue &#125;</span><br><span class="line">&quot;*password:&quot; &#123; send &quot;$passwd\n&quot; &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>expect更详细的说明自行搜索 linux expect</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在Shell脚本中输入密码的几种情况&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;如果是要使用sudo&quot;&gt;如果是要使用sudo&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;首先在Shell脚本中使用sudo不是一个好主意。&lt;/p&gt;
&lt;p&gt;可以考虑的替代方案有，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在脚本中去</summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
    <category term="ssh-tunnel" scheme="https://kyo86.com/tags/ssh-tunnel/"/>
    
  </entry>
  
  <entry>
    <title>迁移git项目</title>
    <link href="https://kyo86.com/2022/02/08/migra-git-repository/"/>
    <id>https://kyo86.com/2022/02/08/migra-git-repository/</id>
    <published>2022-02-07T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone --mirror &lt;原地址&gt;   # 会取得 项目名.git 的目录，里面是包含了提交历史、分支等的完整项目库</span><br><span class="line">cd &lt;项目名.git&gt;</span><br><span class="line">git remote set-url --push origin &lt;新地址&gt;   # 新地址是提前创建好的（空白的）新项目库路径</span><br><span class="line">git push --mirror</span><br></pre></td></tr></table></figure><p>告知其他合作开发者修改远程库路径到新地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin &lt;新地址&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v # 可以查看当前设置的地址 </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
    <category term="git" scheme="https://kyo86.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>pandas df.to_excel 设置列宽遇到 AttributeError: &#39;Worksheet&#39; object has no attribute &#39;column_dimensions&#39;</title>
    <link href="https://kyo86.com/2021/12/23/df-to-excel-set-width/"/>
    <id>https://kyo86.com/2021/12/23/df-to-excel-set-width/</id>
    <published>2021-12-22T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<p>df.to_excel底层默认优先用的是xlsxwriter，sheet对象的类型是 xlsxwriter.worksheet.Worksheet，它没有column_dimensions属性。<br>可以通过在创建ExcelWriter的时候指定engine&#x3D;”openpyxl”让底层使用openpyxl，sheet对象的类型会变成openpyxl.worksheet.worksheet.Worksheet，它是有column_dimensions属性的。<br>需要安装过 openpyxl 库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">with pd.ExcelWriter(f&quot;xxx.xlsx&quot;,</span><br><span class="line">          engine=&quot;openpyxl&quot;,</span><br><span class="line">          date_format=&quot;YYYY-MM-DD&quot;,</span><br><span class="line">          datetime_format=&quot;YYYY-MM-DD HH:MM:SS&quot;</span><br><span class="line">          ) as writer:</span><br><span class="line">  df.to_excel(writer)</span><br><span class="line">  sheet = writer.sheets[&quot;Sheet1&quot;]</span><br><span class="line">  # 设置列宽</span><br><span class="line">  sheet.column_dimensions[&#x27;A&#x27;].width = 12.5</span><br><span class="line">  # 设置行高</span><br><span class="line">  sheet.row_dimensions[1].height = 72</span><br><span class="line">  # 设置表头（第一行）自动换行</span><br><span class="line">  r = sheet[1]</span><br><span class="line">  for c in r:</span><br><span class="line">    c.alignment = openpyxl.styles.Alignment(wrapText=True)</span><br><span class="line">  # 设置表体数字格式显示4位小数</span><br><span class="line">  for i, r in enumerate(sheet):</span><br><span class="line">    for j, c in enumerate(r):</span><br><span class="line">      if i != 0 and j != 0:</span><br><span class="line">        c.number_format = &quot;0.0000&quot; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;df.to_excel底层默认优先用的是xlsxwriter，sheet对象的类型是 xlsxwriter.worksheet.Worksheet，它没有column_dimensions属性。&lt;br&gt;可以通过在创建ExcelWriter的时候指定engine&amp;#x3D;”</summary>
      
    
    
    
    
    <category term="python" scheme="https://kyo86.com/tags/python/"/>
    
    <category term="pandas" scheme="https://kyo86.com/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>记一次Linux因硬盘设备编号错位挂载失败引起启动失败的解决过程</title>
    <link href="https://kyo86.com/2021/10/25/linux-mount-error-on-boot/"/>
    <id>https://kyo86.com/2021/10/25/linux-mount-error-on-boot/</id>
    <published>2021-10-24T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="问题描述">问题描述</span></h4><p>周末办公楼电力系统维护停电3小时，服务器关机，电力恢复后服务器启动失败，现象是启动报错，提示让输入密码进入紧急模式。<br>看到主要的错误描述是：<br>CIFS VFS: ioctl error in smb2_get_dfs_refer rc&#x3D;-5<br>怀疑和mount有关。<br>输入密码进入紧急模式，输入命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -a</span><br></pre></td></tr></table></figure><p>即根据配置文件&#x2F;etc&#x2F;fstab进行挂载(正常启动时也是根据此文件进行挂载)<br>其中&#x2F;etc&#x2F;fstab的内容如下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……省略若干</span><br><span class="line">/dev/md126p1    /data   ext4    defaults 0      0</span><br><span class="line">/dev/sdd1       /data2        ext4    defaults 0      0</span><br><span class="line">……省略若干</span><br></pre></td></tr></table></figure><p>执行后看到了具体的挂载错误条目是找不到设备 &#x2F;dev&#x2F;sdd1<br>使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure><p>可以看到存在&#x2F;dev&#x2F;sdd和&#x2F;dev&#x2F;sdd1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sdd: 3.7 TiB, 4000787030016 bytes, 7814037168 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: gpt</span><br><span class="line">Disk identifier: 737D5D12-456A-414A-86DC-0F8279EDA29B</span><br><span class="line"></span><br><span class="line">Device     Start        End    Sectors Size Type</span><br><span class="line">/dev/sdd1   2048 4294969343 4294967296   2T Linux filesystem</span><br></pre></td></tr></table></figure><p> 使用命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsblk</span><br></pre></td></tr></table></figure><p>列出块设备信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NAME        MAJ:MIN RM   SIZE RO TYPE  MOUNTPOINT</span><br><span class="line">loop0         7:0    0  99.4M  1 loop  /snap/core/11993</span><br><span class="line">loop1         7:1    0  99.5M  1 loop  /snap/core/11798</span><br><span class="line">sda           8:0    0 931.5G  0 disk</span><br><span class="line">├─sda1        8:1    0   512M  0 part</span><br><span class="line">└─sda2        8:2    0   931G  0 part</span><br><span class="line">sdb           8:16   0   1.8T  0 disk</span><br><span class="line">├─sdb1        8:17   0   512M  0 part  /boot/efi</span><br><span class="line">└─sdb2        8:18   0   1.8T  0 part  /</span><br><span class="line">sdc           8:32   0   1.8T  0 disk</span><br><span class="line">└─sdc1        8:33   0   1.8T  0 part  /data2</span><br><span class="line">sdd           8:48   0   3.7T  0 disk</span><br><span class="line">└─md126       9:126  0   3.7T  0 raid0</span><br><span class="line">  └─md126p1 259:0    0     2T  0 md    /data</span><br><span class="line">sr0          11:0    1  1024M  0 rom</span><br></pre></td></tr></table></figure><p>发现sdd下面是md126 md126p1，想起来有一块盘做成了raid0，挂载时不能按照sda、sdb、sdc的命名方式挂载，需要用&#x2F;dev&#x2F;md126p1，但这不是问题，因为fstab文件中确实使用了&#x2F;dev&#x2F;md126p1，但不应该挂载&#x2F;dev&#x2F;sdd1了啊，其实是这次重启之后原来的sdd1变成了现在的sdc1，可能因为上次的磁盘是热插入的，重启之后根据插入口的顺序重新分配了设备名，把fstab文件中的sdd1改成sdc1，重新mount -a成功，进入&#x2F;data2查看文件，确实是之前sdd1上的。 </p><p>重启会重新分配设备名导致挂载失败的问题，根据<a href="https://blog.csdn.net/weixin_34552525/article/details/116731517">linux下磁盘sda,Linux下磁盘设备文件（sda,sdb,sdc….）变化问题_林声飘扬的博客-CSDN博客</a>这篇博文的说法，目前没有办法直接解决，但是可以通过指定id和uuid的方式挂载而不使用sda、sdb这种名称来绕过这个问题 </p><p>使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -la /dev/disk/by-id</span><br><span class="line">ls -la /dev/disk/by-uuid</span><br></pre></td></tr></table></figure><p>可以看到这些id和uuid就是指向sda、sdb之类的软连接，而id和uuid每次启动是固定的，那么这些软连接应该是在启动过程中生成的。<br>最后保险起见，我将fstab文件中的挂载设备改成了id表示 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># /dev/sdc1       /data2        ext4    defaults 0      0</span><br><span class="line">/dev/disk/by-id/ata-ST2000NM0055-1V4104_ZC20W9TN-part1 /data2            ext4    defaults 0      0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4&gt;&lt;span id=&quot;问题描述&quot;&gt;问题描述&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;周末办公楼电力系统维护停电3小时，服务器关机，电力恢复后服务器启动失败，现象是启动报错，提示让输入密码进入紧急模式。&lt;br&gt;看到主要的错误描述是：&lt;br&gt;CIFS VFS: ioctl error in</summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
    <category term="trouble-shooting" scheme="https://kyo86.com/tags/trouble-shooting/"/>
    
  </entry>
  
  <entry>
    <title>SSH Tunnel</title>
    <link href="https://kyo86.com/2021/02/18/ssh-tunnel/"/>
    <id>https://kyo86.com/2021/02/18/ssh-tunnel/</id>
    <published>2021-02-17T16:00:00.000Z</published>
    <updated>2022-04-24T08:58:05.286Z</updated>
    
    <content type="html"><![CDATA[<p>SSH Tunnel解决的问题是让原本不能被访问的端口（通常是因为在不同局域网）可以被访问。</p><p>SSH Tunne按监听端口是本地还是远程分为两种命令，格式分别如下：</p><p>在本地端口(bind_address:port，指定bind_address是因为本机可能有多个网络接口，缺省在localhost上监听，只接受来自本机的链接，接受任意需指定为*)上开启监听，将收到的数据通过tunnel转发到(hostname:22)，在由hostname转发到host:hostport</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-L [bind_address:]port:host:hostport] [user@]hostname -p 22</span><br></pre></td></tr></table></figure><p>在远程端口(bind_address:port)上开启监听，将收到的数据通过tunnel转发到本机，再由本机转发到(host:hostport)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-R [bind_address:]port:host:hostport] [user@]hostname -p 22</span><br></pre></td></tr></table></figure><h5><span id="用法举例">用法举例</span></h5><p>假设A要访问D:6379，A、D在不同局域网，最简单方法是在D所在的局域网网关上配置端口映射把D:6379映射到公网，但是很多时候出于某些因素（例如：安全考量、没有配置网关的权限、服务本身配置了只允许本地访问），不希望或无法通过把D:6379映射到公网解决，就可以考虑使用SSH Tunnel。</p><h6><span id="情形1">情形1：</span></h6><p>D所在的局域网有主机C的22端口是被映射到公网的，不妨假设映射成了X:30022，X是C和D所在局域网网关在公网的IP地址，那么可以在主机A上通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostA$ ssh -L 36379:D:6379 root@X -p 30022</span><br></pre></td></tr></table></figure><p>把D:6379映射成了A:36379，特别情况C和D是同一台主机，D可以写成localhost。</p><h6><span id="情形2">情形2：</span></h6><p>A所在的局域网有主机B的22端口是被映射到公网的，不妨假设映射成了X:30022，X是A和B所在局域网网关在公网的IP地址，那么可以在主机D上通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostD$ ssh -g -R 36379:D:6379 root@X -p 30022</span><br></pre></td></tr></table></figure><p>把D:6379映射成了B:36379，而A和B是同一局域网的，因此A可以访问到B:36379。</p><p>按理说上面的命令加了-g参数，B:36379应该被绑定在0.0.0.0:36379，但实际测试发现绑定在了127.0.0.1:36379，导致无法在A上访问，原因暂时未知（确定不是因为redis配置了保护模式），不过可以通过类似情形1的方式再把B:36379映射成A:36379，这样A就可以访问了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostA$ ssh -L 36379:localhost:36379 root@B</span><br></pre></td></tr></table></figure><h6><span id="情形3">情形3：</span></h6><p>A和D所在局域网都没有主机的ssh端口被映射到公网，但我有另一台具有公网IP的主机，不妨假设为X开启着22端口，类似情形2通过命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostD$ ssh -R 36379:D:6379 root@X</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostA$ ssh -L 36379:localhost:36379 root@X</span><br></pre></td></tr></table></figure><p>之后让A访问A:36379即可。</p><p>通过命令建立SSH Tunnel之后会登录到作为跳板的机器，通常我们是不需要使用这个控制台的，因此可以通过-f参数让ssh在后台运行，需要关闭tunnel时直接杀死进程。</p><h5><span id="常用选项">常用选项</span></h5><p>C表示压缩数据传输</p><p>f表示后台用户验证,这个选项很有用,没有shell的不可登陆账号也能使用.</p><p>N表示不执行脚本或命令</p><p>g表示允许远程主机连接转发端口</p><p>例如情形1中的命令可以写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -CfNg -L 36379:D:6379 root@X -p 30022</span><br></pre></td></tr></table></figure><p>通过</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep ssh -CfNg</span><br></pre></td></tr></table></figure><p>可以查看打开的tunnel。</p><p>当网络不稳定时，ssh tunnel会自动断开，如果是前台的运行方式，会自动退出远程控制台，回到本地控制台提示符，如果是后台运行方式，进程会自动结束，这时候可以使用autossh工具来帮助自动重连。</p><p>只需要把ssh命令中的ssh换成autossh -M <port></port></p><p>例如情形1中的命令可以写成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autossh -M 46379 -CfNg -L 36379:D:6379 root@X -p 30022</span><br></pre></td></tr></table></figure><p>-M 后面的端口号是用来监视连接状态的，允许指定为0，这里指定为0是否可以正常监视重连以及如何监视有待研究。</p><p>另外如果autossh带了-f参数则不支持输入密码，可以配合expect脚本自动输入密码或者通过SSH密钥登录，更推荐使用密钥方式。</p><h5><span id="生成密钥">生成密钥</span></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><p>会询问将密钥放在何处，默认即可。然后是输入密码，留空(否则你登录不仅需要私钥还要输入密码)。</p><p>完成后在~&#x2F;.ssh目录下会生成另个文件id_rsa和id_rsa.pub，一个私钥一个公钥。</p><p>然后将公钥写入远程用户家目录下的~&#x2F;.ssh&#x2F;authorized_keys文件中，通过ssh-copy-id命令可以帮我们实现这一操作（相当于把公钥复制过去再追加到authorized_keys的尾部）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [-p SSH端口默认22] [user@]hostname</span><br></pre></td></tr></table></figure><h5><span id="参考">参考：</span></h5><p><a href="https://blog.csdn.net/wxqee/article/details/49234595">https://blog.csdn.net/wxqee/article/details/49234595</a></p><p><a href="https://www.cnblogs.com/youxin/p/5220916.html">https://www.cnblogs.com/youxin/p/5220916.html</a></p><p><a href="https://blog.csdn.net/wesleyflagon/article/details/85304336">https://blog.csdn.net/wesleyflagon/article/details/85304336</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;SSH Tunnel解决的问题是让原本不能被访问的端口（通常是因为在不同局域网）可以被访问。&lt;/p&gt;
&lt;p&gt;SSH Tunne按监听端口是本地还是远程分为两种命令，格式分别如下：&lt;/p&gt;
&lt;p&gt;在本地端口(bind_address:port，指定bind_address是因</summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
    <category term="ssh-tunnel" scheme="https://kyo86.com/tags/ssh-tunnel/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js前端跨域请求代理设置方法</title>
    <link href="https://kyo86.com/2021/02/02/vue-cross-domain/"/>
    <id>https://kyo86.com/2021/02/02/vue-cross-domain/</id>
    <published>2021-02-02T06:59:44.000Z</published>
    <updated>2022-04-19T11:39:25.914Z</updated>
    
    <content type="html"><![CDATA[<p>假设后端服务器跑在backend-server:30101，跑在本地就是localhost:30101</p><p>开发环境下通过 config&#x2F;index.js 配置代理 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// see http://vuejs-templates.github.io/webpack for documentation.</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">build</span>: &#123;</span><br><span class="line">        <span class="attr">env</span>: <span class="built_in">require</span>(<span class="string">&#x27;./prod.env&#x27;</span>),</span><br><span class="line">        <span class="attr">index</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist/index.html&#x27;</span>),</span><br><span class="line">        <span class="attr">assetsRoot</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;../dist&#x27;</span>),</span><br><span class="line">        <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">        <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/view/&#x27;</span>,</span><br><span class="line">        <span class="attr">productionSourceMap</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// Gzip off by default as many popular static hosts such as</span></span><br><span class="line">        <span class="comment">// Surge or Netlify already gzip all static assets for you.</span></span><br><span class="line">        <span class="comment">// Before setting to `true`, make sure to:</span></span><br><span class="line">        <span class="comment">// npm install --save-dev compression-webpack-plugin</span></span><br><span class="line">        <span class="attr">productionGzip</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">productionGzipExtensions</span>: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;css&#x27;</span>],</span><br><span class="line">        <span class="comment">// Run the build command with an extra argument to</span></span><br><span class="line">        <span class="comment">// View the bundle analyzer report after build finishes:</span></span><br><span class="line">        <span class="comment">// `npm run build --report`</span></span><br><span class="line">        <span class="comment">// Set to `true` or `false` to always turn it on or off</span></span><br><span class="line">        <span class="attr">bundleAnalyzerReport</span>: process.<span class="property">env</span>.<span class="property">npm_config_report</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">dev</span>: &#123;</span><br><span class="line">        <span class="attr">env</span>: <span class="built_in">require</span>(<span class="string">&#x27;./dev.env&#x27;</span>),</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">        <span class="attr">autoOpenBrowser</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">assetsSubDirectory</span>: <span class="string">&#x27;static&#x27;</span>,</span><br><span class="line">        <span class="attr">assetsPublicPath</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">proxyTable</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                <span class="attr">target</span>: <span class="string">&quot;http://backend-server:30101&quot;</span>, <span class="comment">// 测试环境下配置端口转发</span></span><br><span class="line">                <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">                    <span class="string">&quot;^/api&quot;</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 重写路径，去掉前缀api</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// CSS Sourcemaps off by default because relative paths are &quot;buggy&quot;</span></span><br><span class="line">        <span class="comment">// with this option, according to the CSS-Loader README</span></span><br><span class="line">        <span class="comment">// (https://github.com/webpack/css-loader#sourcemaps)</span></span><br><span class="line">        <span class="comment">// In our experience, they generally work as expected,</span></span><br><span class="line">        <span class="comment">// just be aware of this issue when enabling this option.</span></span><br><span class="line">        <span class="attr">cssSourceMap</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产环境下通过前端所在服务器上的Nginx配置代理在<br>&#x2F;etc&#x2F;nginx&#x2F;sites-enabled&#x2F;default<br>中添加 location ^~&#x2F;api&#x2F; 对应的块 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    # ......</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # First attempt to serve request as file, then</span><br><span class="line">        # as directory, then fall back to displaying a 404.</span><br><span class="line">        try_files $uri $uri/ =404;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~/api/ &#123;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header  X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header  X-NginX-Proxy true;</span><br><span class="line">        proxy_read_timeout    300;</span><br><span class="line"></span><br><span class="line">        rewrite ^/api/(.*)$ /$1 break;</span><br><span class="line">        proxy_pass http://backend-server:30101/;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    # ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;假设后端服务器跑在backend-server:30101，跑在本地就是localhost:30101&lt;/p&gt;
&lt;p&gt;开发环境下通过 config&amp;#x2F;index.js 配置代理 &lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="vue.js" scheme="https://kyo86.com/tags/vue-js/"/>
    
  </entry>
  
  <entry>
    <title>Linux限制目录大小</title>
    <link href="https://kyo86.com/2021/02/02/linux-limit-directory-size/"/>
    <id>https://kyo86.com/2021/02/02/linux-limit-directory-size/</id>
    <published>2021-02-01T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<p>需求情景：</p><p>存放日志或接收并存储数据的目录，为了防止程序出错时疯狂写日志硬盘被日志或存储的数据塞满。</p><p>原理，创建一个固定大小的img文件，映射成一个目录 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 创建Log.img大小1G</span><br><span class="line">dd if=/dev/zero of=./Log.img bs=1M count=1024</span><br><span class="line"># 格式化 ext4</span><br><span class="line">mkfs.ext4 ./Log.img</span><br><span class="line"># 创建挂载目录</span><br><span class="line">mkdir ./Log</span><br><span class="line"># 挂载</span><br><span class="line">sudo mount -o loop ./Log.img ./Log</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;需求情景：&lt;/p&gt;
&lt;p&gt;存放日志或接收并存储数据的目录，为了防止程序出错时疯狂写日志硬盘被日志或存储的数据塞满。&lt;/p&gt;
&lt;p&gt;原理，创建一个固定大小的img文件，映射成一个目录 &lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下使用PPTPD搭建VPN</title>
    <link href="https://kyo86.com/2021/02/01/ubuntu-pptpd/"/>
    <id>https://kyo86.com/2021/02/01/ubuntu-pptpd/</id>
    <published>2021-01-31T16:00:00.000Z</published>
    <updated>2022-04-19T11:39:25.914Z</updated>
    
    <content type="html"><![CDATA[<h3><span id="搭建pptp服务器">搭建PPTP服务器</span></h3><p>参考：<a href="https://blog.csdn.net/sanve/article/details/80882731">https://blog.csdn.net/sanve/article/details/80882731</a></p><p><strong>安装</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install pptpd</span><br></pre></td></tr></table></figure><p><strong>配置IP</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/pptpd.conf</span><br></pre></td></tr></table></figure><p>查找并解开这3处的注释并修改相应配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#bcrelay eth1 </span><br><span class="line">#localip 192.168.10.1</span><br><span class="line">#remoteip 192.168.10.234-238,192.168.10.245</span><br></pre></td></tr></table></figure><p>bcrelay的意思我理解是来自虚拟局域网的广播要从哪个物理网卡转发出去</p><p>localip的意思本机是VPN服务器的IP地址</p><p>remoteip的意思是当有远程VPN客户端连接上来时被分配的IP段</p><p>我认为应该把虚拟局域网的网段和物理局域网分开，而且localip和remoteip应该在同一个网段，网上有localip和remoteip不应该在同一个网段的说法我并不认同。</p><p><strong>配置DNS</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/pptpd-options </span><br></pre></td></tr></table></figure><p>找到ms-dns解开注释并修改相应配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ms-dns 114.114.114.114</span><br><span class="line">ms-dns 8.8.8.8</span><br></pre></td></tr></table></figure><p><strong>配置用户名密码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/chap-secrets </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Secrets for authentication using CHAP</span><br><span class="line"># client      server    secret         IP addresses</span><br><span class="line">&lt;username&gt;  pptpd  &lt;password&gt;        *</span><br></pre></td></tr></table></figure><p>修改配置后重启PPTP服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service pptpd restart </span><br></pre></td></tr></table></figure><p><strong>打开IPv4转发</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf </span><br></pre></td></tr></table></figure><p>找到并修改或添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.ip_forward = 1 </span><br></pre></td></tr></table></figure><p>使配置生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p service</span><br><span class="line">procps restart </span><br></pre></td></tr></table></figure><p>在网关上添加指向VPN网段的静态路由，设置下一跳地址为架设VPN服务器主机的IP，这样整个局域网都是可以通过VPN正常访问的。</p><p>如果没有操作网关的权限，也可以在需要访问的主机上添加静态路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip route add 192.168.10.0/24 via 192.168.1.99 </span><br></pre></td></tr></table></figure><p>这里192.168.1.99就是架设VPN服务器的主机IP</p><h4><span id="ubuntu-pptp客户端">Ubuntu PPTP客户端</span></h4><p>参考：<a href="https://www.jianshu.com/p/1680c721f397">https://www.jianshu.com/p/1680c721f397</a> <a href="http://www.linuxfly.org/post/641/">http://www.linuxfly.org/post/641/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pptpsetup --create 连接名 --server VPN服务器地址 --username 用户名 --password 密码 --encrypt</span><br></pre></td></tr></table></figure><p> 启动VPN连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pon 连接名</span><br></pre></td></tr></table></figure><p>关闭VPN连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poff 连接名</span><br></pre></td></tr></table></figure><p>查看路由表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -n</span><br></pre></td></tr></table></figure><p>添加路由，将通过VPN接入的物理局域网网段路由指定通过ppp0网口转发</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 192.168.1.0 netmask 255.255.255.0 dev ppp0 </span><br></pre></td></tr></table></figure><p>每次重连后路由会丢失，需要重新配置，可以用下面的方法在ppp0 up时自动添加路由</p><h4><span id="pptp连接时自启动添加路由">pptp连接时自启动添加路由</span></h4><p>参考：<a href="https://blog.csdn.net/qq_27434019/article/details/102920504">https://blog.csdn.net/qq_27434019/article/details/102920504</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/peers/连接名 </span><br></pre></td></tr></table></figure><p>增加ipparam一行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipparam 连接名 </span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;下面这步似乎不必要，不清楚作用&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/network/interfaces </span><br></pre></td></tr></table></figure><p>增加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto tunnel</span><br><span class="line">iface tunnel inet ppp</span><br><span class="line">provider 连接名</span><br></pre></td></tr></table></figure><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</p><p>新建脚本文件并修改权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch /etc/ppp/ip-up.d/连接名</span><br><span class="line">chmod a+x /etc/ppp/ip-up.d/连接名</span><br></pre></td></tr></table></figure><p>编辑脚本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/ppp/ip-up.d/连接名 </span><br></pre></td></tr></table></figure><p>在脚本中加入添加路由的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route add -net 192.168.1.0 netmask 255.255.255.0 dev ppp0</span><br></pre></td></tr></table></figure><p>可以poff 再 pon 再 route -n 看看路由是否自动添加</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3&gt;&lt;span id=&quot;搭建pptp服务器&quot;&gt;搭建PPTP服务器&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/sanve/article/details/80882731&quot;&gt;https://blog.csdn.net/san</summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
    <category term="vpn" scheme="https://kyo86.com/tags/vpn/"/>
    
  </entry>
  
  <entry>
    <title>Linux配置共享目录</title>
    <link href="https://kyo86.com/2020/08/27/linux-share/"/>
    <id>https://kyo86.com/2020/08/27/linux-share/</id>
    <published>2020-08-27T09:20:08.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<p>在需要被挂载的服务器上安装nfs-kernel-server</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install nfs-kernel-server</span><br></pre></td></tr></table></figure><p>编辑</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/exports</span><br></pre></td></tr></table></figure><p>样例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># /etc/exports: the access control list for filesystems which may be exported</span><br><span class="line">#               to NFS clients.  See exports(5).</span><br><span class="line">#</span><br><span class="line"># Example for NFSv2 and NFSv3:</span><br><span class="line"># /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)</span><br><span class="line">#</span><br><span class="line"># Example for NFSv4:</span><br><span class="line"># /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)</span><br><span class="line"># /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)</span><br><span class="line">/data/share 192.168.1.157(insecure,rw,sync,no_root_squash,no_subtree_check) *(insecure,ro,async,root_squash,no_subtree_check)</span><br></pre></td></tr></table></figure><p>这里配置了&#x2F;data&#x2F;share为共享目录，允许从192.168.1.157进行读写操作，允许从其他任意IP进行只读操作。</p><p>把共享目录的owner改成 nobody:nogroup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown nobody:nogroup /data/share</span><br></pre></td></tr></table></figure><p>设置共享目录的权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 /data/share</span><br></pre></td></tr></table></figure><p>重新加载配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo exportfs -a</span><br></pre></td></tr></table></figure><p>在需要挂载的服务器需要安装nfs-common</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install nfs-common</span><br></pre></td></tr></table></figure><p>挂载命令样例 ，把140上的&#x2F;data&#x2F;share共享目录挂载到本地&#x2F;mnt&#x2F;140share</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount 192.168.1.140:/data/share /mnt/140share</span><br></pre></td></tr></table></figure><p>使用到的端口，如果有防火墙需要设置</p><p>111&#x2F;tcp+udp</p><p>825&#x2F;tcp</p><p>2049&#x2F;tcp</p><p>4046&#x2F;udp</p><p>如果希望系统启动时自动加载文件系统，则还需要在 &#x2F;etc&#x2F;fstab 中添加内容： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line">192.168.1.140:/data/share /mnt/140share nfs defaults 0 0</span><br></pre></td></tr></table></figure><p>其中nfs是被挂载的路径的类型</p><p>常用的类型有：</p><p>nfs表示远程linux的共享路径</p><p>cifs表示远程windows的共享路径</p><p>ext4表示本地ext4路径</p><p>其中defaults是挂载选项，在挂载windows目录时，通过以下方式指定用户名和密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults,auto,username=XXX,password=XXXXXX,dir_mode=0777,file_mode=0777</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在需要被挂载的服务器上安装nfs-kernel-server&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;</summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
    <category term="nfs" scheme="https://kyo86.com/tags/nfs/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL 10 主从同步配置</title>
    <link href="https://kyo86.com/2020/08/27/psql-master-slave-sync/"/>
    <id>https://kyo86.com/2020/08/27/psql-master-slave-sync/</id>
    <published>2020-08-27T09:06:43.000Z</published>
    <updated>2022-04-19T11:39:25.914Z</updated>
    
    <content type="html"><![CDATA[<p>主服务器：192.168.1.99</p><p>从服务器：192.168.1.150</p><h4><span id="配置主服务器">配置主服务器</span></h4><p>在主服务器创建repl用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE ROLE repl login replication password &#x27;d71ea3&#x27;; </span><br></pre></td></tr></table></figure><p>配置repl用户访问权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/postgresql/10/main/pg_hba.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host    replication     repl            192.168.1.150/32               md5</span><br></pre></td></tr></table></figure><p>配置主服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/postgresql/10/main/postgresql.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wal_level = replica</span><br><span class="line"></span><br><span class="line">archive_mode = on               # enables archiving; off, on, or always</span><br><span class="line">                                # (change requires restart)</span><br><span class="line">archive_command = &#x27;rsync -zaq %p postgres@192.168.1.150:/var/lib/postgresql/wal_restore/%f &amp;&amp; test ! -f /var/lib/postgresql/archivedir/%f &amp;&amp; cp %p /var/lib/postgresql/archivedir/%f&#x27;</span><br><span class="line"></span><br><span class="line">max_wal_senders = 10</span><br><span class="line">wal_keep_segments = 64</span><br><span class="line">wal_sender_timeout = 60s</span><br></pre></td></tr></table></figure><p>归档命令不加入rsync也可以，只需要在建立主从同步时手动把完整备份之后的归档复制到从库，后面配置从库时候会提到。</p><p>我实际使用的归档命令还加入了自动删除旧数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">archive_command = &#x27;DIR=/var/lib/postgresql/archivedir; test ! -f $DIR/%f &amp;&amp; cp --preserve=timestamps %p $DIR/%f; find $DIR -type f -mtime +31|xargs rm -f&#x27;</span><br></pre></td></tr></table></figure><p>重启服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service postgresql restart</span><br></pre></td></tr></table></figure><h4><span id="配置从服务器">配置从服务器</span></h4><p>停止服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service postgresql stop</span><br></pre></td></tr></table></figure><p>删除所有数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/postgresql/10/main</span><br><span class="line"></span><br><span class="line">rm -rf *</span><br></pre></td></tr></table></figure><p>配置从服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/postgresql/10/main/postgresql.conf</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hot_standby = on</span><br></pre></td></tr></table></figure><p>切换到postgres用户</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su - postgres</span><br></pre></td></tr></table></figure><p>从主服务器创建初始备份，上面切换用户是为了不用调整文件权限</p><p>pg_basebackup -h 192.168.1.99 -U repl -D &#x2F;var&#x2F;lib&#x2F;postgresql&#x2F;10&#x2F;main -F p -X stream -P -R -p 5432</p><p>Password: d71ea3</p><p>会自动生成 recovery.conf 启动之后会读取里面的配置进行主从同步</p><p>切回root</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo su -</span><br></pre></td></tr></table></figure><p>如果前面主服务器归档命令没有加入rsync，那么我们现在在<strong>主服务器上</strong> 复制最近一天内修改过的归档文件到从服务器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/postgresql/archivedir</span><br><span class="line">find -mtime -1|xargs -n 1 -I&#123;&#125; scp /var/lib/postgresql/archivedir/&#123;&#125; postgres@192.168.1.150:/var/lib/postgresql/wal_restore/</span><br></pre></td></tr></table></figure><p>相当于整体上从库建立起同步需要的数据 &#x3D; 完整备份 + 归档文件 + WAL缓存 </p><p>从服务器启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service postgresql start</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;主服务器：192.168.1.99&lt;/p&gt;
&lt;p&gt;从服务器：192.168.1.150&lt;/p&gt;
&lt;h4&gt;&lt;span id=&quot;配置主服务器&quot;&gt;配置主服务器&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;在主服务器创建repl用户&lt;/p&gt;
&lt;figure class=&quot;highlight pla</summary>
      
    
    
    
    
    <category term="PostgreSQL" scheme="https://kyo86.com/tags/PostgreSQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux .service文件 创建服务、配置服务自启动</title>
    <link href="https://kyo86.com/2020/06/28/linux-service/"/>
    <id>https://kyo86.com/2020/06/28/linux-service/</id>
    <published>2020-06-28T01:53:54.000Z</published>
    <updated>2022-04-19T11:39:25.901Z</updated>
    
    <content type="html"><![CDATA[<p>查看系统进程运行状态，包括服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status</span><br></pre></td></tr></table></figure><p>所有可用的单元文件存放在 &#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 和 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 目录。</p><p>根据我的实验情况是我们应该在&#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 下存放.service文件，当设置了自启动后，会自动在 &#x2F;etc&#x2F;systemd&#x2F;system&#x2F; 下创建一个软链接指向 &#x2F;lib&#x2F;systemd&#x2F;system&#x2F; 下的文件。</p><p>查看所有已安装服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-units --type=service</span><br></pre></td></tr></table></figure><p>通过服务状态可以查看启动服务的.service配置文件</p><p>例如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mongodb status</span><br></pre></td></tr></table></figure><p>可以看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/lib/systemd/system/mongodb.service</span><br></pre></td></tr></table></figure><p>最重要的，运行命令，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ExecStart=/usr/bin/mongod --unixSocketPrefix=$&#123;SOCKETPATH&#125; --config $&#123;CONF&#125; $DAEMON_OPTS</span><br></pre></td></tr></table></figure><p>PS:要注意的是ExecStart指定的是一个阻塞的程序，不需要后台执行，如果不阻塞，服务会认为程序执行完了，认为服务不在启动状态。</p><p>以Kafka为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Kafka Server</span><br><span class="line">After=network.target zookeeper.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/opt/kafka_2.12-2.3.1/bin/kafka-server-start.sh /opt/kafka_2.12-2.3.1/config/server.properties</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartPreventExitStatus=255</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">Alias=kafka.service</span><br></pre></td></tr></table></figure><p>详细的.service文件编写方法可以参考 <a href="http://www.jinbuguo.com/systemd/systemd.service.html">http://www.jinbuguo.com/systemd/systemd.service.html</a></p><p>修改服务配置文件后需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>设置服务开机自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable postgresql.service</span><br></pre></td></tr></table></figure><p>查询是否自启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl is-enabled postgresql.service</span><br></pre></td></tr></table></figure><p>取消服务器开机自启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl disable postgresql.service</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;查看系统进程运行状态，包括服务&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td </summary>
      
    
    
    
    
    <category term="linux" scheme="https://kyo86.com/tags/linux/"/>
    
  </entry>
  
</feed>
